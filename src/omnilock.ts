import fs from 'fs';
import { hd, utils, config, helpers, RPC, Input, Indexer, commons, HashType } from '@ckb-lumos/lumos';
import { bytes, blockchain, Uint8, Uint64, Uint128 } from '@ckb-lumos/lumos/codec';
import { CKT_RPC_URL, CKT_INDEXER_URL } from './constants';
import { tom } from './accounts';

config.initializeConfig(config.TESTNET);

const { computeScriptHash } = utils;
const { bytify, hexify, concat } = bytes;
const { signRecoverable, publicKeyToBlake160 } = hd.key;
const { XUDT, OMNILOCK } = config.TESTNET.SCRIPTS;

const MAX_SUPPLY = +process.argv[2] || 10000;
const CURRENT_SUPPLY = 0;
const TYPE_ID_PLACEHOLDER = {
  codeHash: "0x00000000000000000000000000000000000000000000000000545950455f4944",
  hashType: "type" as HashType,
  args: hexify(new Uint8Array(32)),   // 32 bytes placeholder
};

function generateTypeIdArgs(input: Input, index: number) {
  const hasher = new utils.CKBHasher();
  hasher.update(blockchain.CellInput.pack(input));
  hasher.update(Uint64.pack(index));
  return hasher.digestHex();
}

async function main() {
  const rpc = new RPC(CKT_RPC_URL);
  const indexer = new Indexer(CKT_INDEXER_URL);
  const xudt = {
    codeHash: XUDT.CODE_HASH,
    hashType: XUDT.HASH_TYPE,
    args: utils.computeScriptHash(helpers.parseAddress(tom.address)),
  };

  const omnilock = {
    codeHash: OMNILOCK.CODE_HASH,
    hashType: OMNILOCK.HASH_TYPE,
    args: "0x00" + publicKeyToBlake160(tom.publicKey).slice(2) + "08" + computeScriptHash(TYPE_ID_PLACEHOLDER).slice(2),
  };
  
  // https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0042-omnilock/0042-omnilock.md#supply-mode
  const data = hexify(concat(
    Uint8.pack(0),                // version
    Uint128.pack(CURRENT_SUPPLY), // only the current supply field can be updated during transactions.
    Uint128.pack(MAX_SUPPLY),
    bytify(utils.computeScriptHash(xudt))
  ));
  
  const cell = helpers.cellHelper.create({
    lock: omnilock,
    type: TYPE_ID_PLACEHOLDER,
    data
  });

  let txSkeleton = helpers.TransactionSkeleton({ cellProvider: indexer });

  txSkeleton = helpers.addCellDep(txSkeleton, {
    depType: XUDT.DEP_TYPE,
    outPoint: {
      txHash: XUDT.TX_HASH,
      index: XUDT.INDEX
    }
  });

  txSkeleton = helpers.addCellDep(txSkeleton, {
    depType: OMNILOCK.DEP_TYPE,
    outPoint: {
      txHash: OMNILOCK.TX_HASH,
      index: OMNILOCK.INDEX
    }
  });

  txSkeleton = await commons.common.injectCapacity(txSkeleton, [tom.address], cell.cellOutput.capacity);

  cell.cellOutput.type!.args = generateTypeIdArgs({
    previousOutput: txSkeleton.get('inputs').get(0)!.outPoint!,
    since: txSkeleton.get('inputSinces').get(0, '0x0'),
  }, txSkeleton.get('outputs').size);

  cell.cellOutput.lock.args = "0x00" + publicKeyToBlake160(tom.publicKey).slice(2) + "08" + computeScriptHash(cell.cellOutput.type!).slice(2),

  txSkeleton = txSkeleton.update('outputs', (outputs) => outputs.push(cell));
  txSkeleton = await commons.common.payFeeByFeeRate(txSkeleton, [tom.address], BigInt(1000));
  txSkeleton = commons.common.prepareSigningEntries(txSkeleton);

  const signatures = txSkeleton
    .get('signingEntries')
    .map(({ message }) => signRecoverable(message, tom.secretKey))
    .toArray();
  const tx = helpers.sealTransaction(txSkeleton, signatures);
  tx.hash = await rpc.sendTransaction(tx);
  console.log('tx', tx);

  fs.writeFileSync('./omnilock_data.ts', `// This file is generated by omnilock.ts
import { Script } from '@ckb-lumos/lumos';
export const TYPE_ID_SCRIPT = ${JSON.stringify(cell.cellOutput.type, null, 2)} as Script;

export const MAX_SUPPLY = ${MAX_SUPPLY};

export const CURRENT_SUPPLY = ${CURRENT_SUPPLY};

export const XUDT_SCRIPT = ${JSON.stringify(xudt, null, 2)} as Script;

export const XUDT_SCRIPT_HASH = "${computeScriptHash(xudt)}";

export const OMNILOCK_SCRIPT = ${JSON.stringify(cell.cellOutput.lock, null, 2)} as Script;

export const OMNILOCK_SCRIPT_HASH = "${computeScriptHash(omnilock)}";

export const OMNILOCK_TRANSACTION = ${JSON.stringify(tx, null, 2)};
`);
  console.log('view generated data in omnilock_data.ts');
}

main();